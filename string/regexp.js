//正则: 也叫做规则, 让计算机能够读懂人类的规则, 正则是一个系统对象.  正则都是操作字符串的,且只能操作字符串

// 一般创建系统对象:  var arr = []  就是等效于   var arr = new Array();    var  obj = {}  就是等效于 var obj = new Object();
//正则的创建对象方式就是 :  var re = //   等效于   var  re = new  RegExp();  
//Reg : 正则的简写    Exp: 表达式的简写,  合起来就是 正则表达式 
//大部分使用  var re = //   性能较优, 最好不让出现2个反斜杠, 这样会认为是注释 所以添加一点内容 /a/ 
//在正则需要接受变量的时候, 需要写成正则表达式的标准模式即:   var re = new RegExp("\\b"+argument+"\\b","g"); 
var re = /b/;



//正则表达式里 一共涉及到5个方法, 其中有一个不太常用
// 1.  test :  正则去匹配字符串, 如果匹配成功就返回真, 如果匹配失败就返回假(大白话就是: 正则里面的这个值是不是存在于字符串啊?)     正则.test(字符串)  , 返回布尔值
var   str = "mobbist";
var  re = /bi/ ;
// 正则去匹配字符串中的字符,  找到就返回真,  否则返回假
//alert( re.test(str));
// 转义字符:   当一个字符加上斜杠之后, 其功能就不是原功能了,   比如n  就是字符n,  加上\n就是 换行符
/*
	\s(小写) :  空格
	\S(大写) :  非空格
	\d(小写) :  数字
	\D(大写) :  非数字
	\w(小写) :  字符   (字符包括:  字母, 数字, 下划线_)
	\W(大写) :  非字符 (非字符包括:  特殊字符, 汉字之类)
	.       :   任意字符
	\.	    :   正常的.号字符
	\b      :   独立的部分  (起始, 结束,空格) 意思就是: 这个标示符出现的地方匹配,是不是开头, 还是结束, 还是一个空格
	\B      :   非独立部分
	\1      :   匹配第一个子项, 匹配第一个小括号里的内容
	\2	    :   匹配第二个子项, 以此类推
*/ 
var  str2 = "43232454321";
var  re2 = /\D/;   //意思就是:  里面的内容有没有不是数字的字符啊? 只要找到一个不是数字的就是true,  显然字符串里都是数字, 所有没找到 返回false
//alert(re2.test(str2));

// 2.  search: 正则去匹配字符串,  如果匹配成功, 就返回匹配成功的位置,  匹配失败就返回 -1    字符串.search(正则);
//像这个案例, 正则默认是区分大小写的, 如果希望不区分大小写就再正则末尾加上i,  /b/i   如果是全写正则的话就需要   var re = new RegExp("b","i")加入第二个参数i即可;
var  str3 = "43232B454321";
var  re3 = /b/i;
//alert(str3.search(re3));

// 3. match  :正则去匹配字符串,  如果匹配成功, 就返回匹配成功的数组, 匹配失败就返回返回 NULL        字符串.match(正则)
// 像这个案例, 如果我想要返回的是一个数组, 当成功匹配之后, 就回返回 不会继续匹配, 所以如果想要执行到底就需要在正则末尾加个g, 全局匹配
//再仔细看这个案例, \d实际上是匹配单位的,所以返回的值都是 1,2,3,4 这种.   那如果我想要连接在一起的值在一个数字里怎么做呢?   
//可以使用\d\d 这样就是匹配2位的, 但是 12 是可以匹配的,  3f  则不行了,  如果加到\d\d\d  变成3位的, 那也不行, 我需要的是一个不确定的位数,怎么做?
//量词:  匹配不确定的位置,   + : 至少出现一次\d,  写在\b之后,  结尾的/之前
var str4 = "123fdsaas45fdsa7hgfd89hgfd";
var re4 = /\d+/g;
//alert(str4.match(re4));

//4. replace  正则去匹配字符串,  匹配成功的字符去替换成一个新的字符串,      字符串.replace(正则,新的字符串);
//分析一下这个案例, 将之前学习到的复习一下
// 首先匹配\a+ ,这是一个不确定的a,只要a联系起来的不管出现多少次 都替换成 一个b, 然后由于最后有g的出现. 说明还要继续找, 将出现的2个a,匹配成功 替换为b
var str5 = "aaazza";
var re = /\a+/g;
alert(str5.replace(re,"b"));
//replace的第二个参数不仅可以接受要替换的字符串  还能接受回调函数即:
alert(str5.replace(re,function(str){
	return "b";   //bzzb   和上一个replace同效果,  在回调函数内部已经返回了这个"b", 这个回调函数还接受一个参数str, 这个参数就是匹配到得字符(串)
}))


// 现在有一个需求, 我想匹配到下列字符串中数字后面紧跟的第一个字母, 该怎么做?
// 匹配子项: 小括号 (), 这一个小括号就是代表一个匹配的子项, 所有子项在一起可以称为母项(自称)   还有另外一个意思, 分组操作,  
var str6= "fj432dk432slfdfd";
var re6 = /(\d+)(\w)/g; //这里第一个子项就是匹配不定位数的数字, 第二项就是  字符.  这么做有什么好处呢? 注意看需求, 是要紧跟的第1个字母, 就是说要第二项字符
alert(str6.replace(re6,function(str,str1,str2){//在回调函数的参数里, 第一个参数就是整体(母项),  第二个就是第一个子项, 第三个就是第二个子项 字母
	return str1+"*";	//直接给第一个子项赋值(字母前面的数字);
}));





// 正则表达式的字符类,  字符类 都是用  []表示 , 中括号的整个整体 代表一个字符.
var str7 = "abc";
var re7 = /a[bkd]c/;  //匹配到a后面的意思必须要包含bkd的意思 , 中括号内都是或的关系, 可以不写 | 
alert(re7.test(str7));  
//排除,   ^     在中括号内出现 ^  就是取反的意思,  不包括某些内容,  有点想JS的! 取反的意思
//范围   a-z  h-s   区域范围,  从a到z的26个字母,  h到s的若干个字母,  0-9   0到9的数字  等等

// 转义字符的其中之一:  /1  /2
// /1 匹配第一个子项, 匹配第一个小括号里的内容,  /2 匹配第二个子项, 以此类推
// 作用: 看下列这个正则, 他匹配的是任意2个字符:   ca  是可以的,   ab 也是可以的,  只要是2个字符型的 都是OK得
var ret1 = /\w\w/;
//下列这个正则, 虽然也是匹配2个字符, 但是\1匹配的第一个子项, 他必须完全和第一个子项一致,  如果  ca的话, c和a不一样的, 所以不匹配,  必须要是  cc   aa  bb 这种
var ret2 = /(\w)\1/;

// 在正则表达式最开始用 ^   则表示开始第一个字符
// 在正则表达式最后使用 $   则表示最后的一个字符
// |    组合匹配, 当一个表达式里,如果有多个想要匹配的条件用| 分割
// 正则表达式的量词  量词是用 {}表示,  表示, 最少出现和最多出现的次数    
// {1,5} 最少出现1次, 最多出现5次
// {4,} 最少出现4次,  最多不限制
// {4}  正好出现4次
// +   量词简写:  {1,}  加号是量词的简写, 最少要出现1次,最多不限制
// ?   量词简写: {0,1}  问号是量词的简写,最少可以不出现, 最多出现1次
// *   量词简写: {0,}   星号是量词的简写, 最少可以不出现, 最多不限制

//去除首位空格的正则表达式:
var removeBlank = /^\s+|\s+$/g;

